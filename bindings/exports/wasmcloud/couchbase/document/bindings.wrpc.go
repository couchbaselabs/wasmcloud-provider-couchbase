// Generated by `wit-bindgen-wrpc-go` 0.9.1. DO NOT EDIT!
package document

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wasmcloud__couchbase__types "github.com/couchbase-examples/wasmcloud-provider-couchbase/bindings/wasmcloud/couchbase/types"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	utf8 "unicode/utf8"
	wrpc "wrpc.io/go"
)

type Document = wasmcloud__couchbase__types.Document
type DocumentId = wasmcloud__couchbase__types.DocumentId
type DocumentError = wasmcloud__couchbase__types.DocumentError
type MutationMetadata = wasmcloud__couchbase__types.MutationMetadata
type Time = wasmcloud__couchbase__types.Time
type DurabilityLevel = wasmcloud__couchbase__types.DurabilityLevel
type RetryStrategy = wasmcloud__couchbase__types.RetryStrategy
type RequestSpan = wasmcloud__couchbase__types.RequestSpan
type ReplicaReadLevel = wasmcloud__couchbase__types.ReplicaReadLevel

// Document - Insert ///
//
// Options for performing a document insert
type DocumentInsertOptions struct {
	// When the document should expire (nanoseconds)
	ExpiresInNs uint64
	// (Deprecated)
	// Traditional durability settings for persistence, only usable from Couchbase versions earlier than 6.0
	//
	// See: https://docs.couchbase.com/go-sdk/current/howtos/subdocument-operations.html#1.6@go-sdk::durability.adoc
	PersistTo uint64
	// (Deprecated)
	// Traditional durability settings for replication, only usable from Couchbase versions earlier than 6.0
	//
	// See: https://docs.couchbase.com/go-sdk/current/howtos/subdocument-operations.html#1.6@go-sdk::durability.adoc
	ReplicateTo uint64
	// Durability level for the mutation
	//
	// (this should be used instead of persist-to/replicate-to)
	DurabilityLevel wasmcloud__couchbase__types.DurabilityLevel
	// Timeout that should be used, in nanoseconds
	// Even if a timeout is not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentInsertOptions) String() string { return "DocumentInsertOptions" }

func (v *DocumentInsertOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 7)
	slog.Debug("writing field", "name", "expires-in-ns")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ExpiresInNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-in-ns` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "persist-to")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.PersistTo, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `persist-to` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "replicate-to")
	write2, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ReplicateTo, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `replicate-to` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "durability-level")
	write3, err := (v.DurabilityLevel).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `durability-level` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write4, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write5, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write5 != nil {
		writes[5] = write5
	}
	slog.Debug("writing field", "name", "parent-span")
	write6, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write6 != nil {
		writes[6] = write6
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Document - Replace ///
//
// Options for performing a document replace
type DocumentReplaceOptions struct {
	// CAS revision of the document
	Cas uint64
	// When the document should expire (nanoseconds)
	ExpiresInNs uint64
	// Whether to preserve expiration values set on any documents modified by the query
	PreserveExpiry bool
	// (Deprecated)
	// Traditional durability settings for persistence, only usable from Couchbase versions earlier than 6.0
	//
	// See: https://docs.couchbase.com/go-sdk/current/howtos/subdocument-operations.html#1.6@go-sdk::durability.adoc
	PersistTo uint64
	// (Deprecated)
	// Traditional durability settings for replication, only usable from Couchbase versions earlier than 6.0
	//
	// See: https://docs.couchbase.com/go-sdk/current/howtos/subdocument-operations.html#1.6@go-sdk::durability.adoc
	ReplicateTo uint64
	// Durability level for the mutation
	//
	// (this should be used instead of persist-to/replicate-to)
	DurabilityLevel wasmcloud__couchbase__types.DurabilityLevel
	// Timeout that should be used, in nanoseconds
	// Even if a timeout is not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentReplaceOptions) String() string { return "DocumentReplaceOptions" }

func (v *DocumentReplaceOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 9)
	slog.Debug("writing field", "name", "cas")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.Cas, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `cas` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "expires-in-ns")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ExpiresInNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-in-ns` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "preserve-expiry")
	write2, err := (func(wrpc.IndexWriter) error)(nil), func(v bool, w io.ByteWriter) error {
		if !v {
			slog.Debug("writing `false` byte")
			return w.WriteByte(0)
		}
		slog.Debug("writing `true` byte")
		return w.WriteByte(1)
	}(v.PreserveExpiry, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `preserve-expiry` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "persist-to")
	write3, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.PersistTo, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `persist-to` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "replicate-to")
	write4, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ReplicateTo, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `replicate-to` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}
	slog.Debug("writing field", "name", "durability-level")
	write5, err := (v.DurabilityLevel).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `durability-level` field: %w", err)
	}
	if write5 != nil {
		writes[5] = write5
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write6, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write6 != nil {
		writes[6] = write6
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write7, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write7 != nil {
		writes[7] = write7
	}
	slog.Debug("writing field", "name", "parent-span")
	write8, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write8 != nil {
		writes[8] = write8
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Document - Upsert ///
//
// Options for performing a document upsert
type DocumentUpsertOptions struct {
	// When the document should expire (nanoseconds)
	ExpiresInNs uint64
	// Whether to preserve expiration values set on any documents modified by the query
	PreserveExpiry bool
	// (Deprecated)
	// Traditional durability settings for persistence, only usable from Couchbase versions earlier than 6.0
	//
	// See: https://docs.couchbase.com/go-sdk/current/howtos/subdocument-operations.html#1.6@go-sdk::durability.adoc
	PersistTo uint64
	// (Deprecated)
	// Traditional durability settings for replication, only usable from Couchbase versions earlier than 6.0
	//
	// See: https://docs.couchbase.com/go-sdk/current/howtos/subdocument-operations.html#1.6@go-sdk::durability.adoc
	ReplicateTo uint64
	// Durability level for the mutation
	//
	// (this should be used instead of persist-to/replicate-to)
	DurabilityLevel wasmcloud__couchbase__types.DurabilityLevel
	// Timeout that should be used, in nanoseconds
	// Even if a timeout is not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentUpsertOptions) String() string { return "DocumentUpsertOptions" }

func (v *DocumentUpsertOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 8)
	slog.Debug("writing field", "name", "expires-in-ns")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ExpiresInNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-in-ns` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "preserve-expiry")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v bool, w io.ByteWriter) error {
		if !v {
			slog.Debug("writing `false` byte")
			return w.WriteByte(0)
		}
		slog.Debug("writing `true` byte")
		return w.WriteByte(1)
	}(v.PreserveExpiry, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `preserve-expiry` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "persist-to")
	write2, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.PersistTo, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `persist-to` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "replicate-to")
	write3, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ReplicateTo, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `replicate-to` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "durability-level")
	write4, err := (v.DurabilityLevel).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `durability-level` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write5, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write5 != nil {
		writes[5] = write5
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write6, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write6 != nil {
		writes[6] = write6
	}
	slog.Debug("writing field", "name", "parent-span")
	write7, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write7 != nil {
		writes[7] = write7
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Document - Get ///
//
// Options for performing a document get
type DocumentGetOptions struct {
	// Whether expiry should also be retreived
	WithExpiry bool
	// Perform a projection of only specific paths of the result, returning only
	// the fields indicated by the given list of paths.
	Project []string
	// Timeout that should be used, in nanoseconds
	// If not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// Level of replica read to enable
	UseReplica *ReplicaReadLevel
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentGetOptions) String() string { return "DocumentGetOptions" }

func (v *DocumentGetOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 6)
	slog.Debug("writing field", "name", "with-expiry")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v bool, w io.ByteWriter) error {
		if !v {
			slog.Debug("writing `false` byte")
			return w.WriteByte(0)
		}
		slog.Debug("writing `true` byte")
		return w.WriteByte(1)
	}(v.WithExpiry, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `with-expiry` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "project")
	write1, err := func(v []string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := func(v []string, w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg sync.WaitGroup
					var wgErr atomic.Value
					for index, write := range writes {
						wg.Add(1)
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index nested list writer: %w", err)
						}
						write := write
						go func() {
							defer wg.Done()
							if err := write(w); err != nil {
								wgErr.Store(err)
							}
						}()
					}
					wg.Wait()
					err := wgErr.Load()
					if err == nil {
						return nil
					}
					return err.(error)
				}, nil
			}
			return nil, nil
		}(v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.Project, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `project` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write2, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write3, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "use-replica")
	write4, err := func(v *ReplicaReadLevel, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (*v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.UseReplica, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `use-replica` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}
	slog.Debug("writing field", "name", "parent-span")
	write5, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write5 != nil {
		writes[5] = write5
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Options for retrieving a document from any replica
type DocumentGetAnyReplicaOptions struct {
	// Timeout that should be used, in nanoseconds
	// If not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentGetAnyReplicaOptions) String() string { return "DocumentGetAnyReplicaOptions" }

func (v *DocumentGetAnyReplicaOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 3)
	slog.Debug("writing field", "name", "timeout-ns")
	write0, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write1, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "parent-span")
	write2, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Options for retrieving a document from any replica
type DocumentGetAllReplicaOptions struct {
	// Timeout that should be used, in nanoseconds
	// If not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentGetAllReplicaOptions) String() string { return "DocumentGetAllReplicaOptions" }

func (v *DocumentGetAllReplicaOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 3)
	slog.Debug("writing field", "name", "timeout-ns")
	write0, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write1, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "parent-span")
	write2, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Result of a successfully executed document get
type DocumentGetResult struct {
	// Document that was retrieved
	Document *wasmcloud__couchbase__types.Document
	// CAS revision of the document
	Cas uint64
	// When the document should expire (nanoseconds)
	//
	// Deprecated: use expires-at instead
	ExpiresInNs *uint64
	// Time when the document expires
	//
	// This field may not be present if `document-get-options.with-expiry` is not set
	ExpiresAt *Time
}

func (v *DocumentGetResult) String() string { return "DocumentGetResult" }

func (v *DocumentGetResult) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "document")
	write0, err := (v.Document).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `document` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "cas")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.Cas, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `cas` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "expires-in-ns")
	write2, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ExpiresInNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-in-ns` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "expires-at")
	write3, err := func(v *Time, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ExpiresAt, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-at` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Result from a replica-aware document get
type DocumentGetReplicaResult struct {
	// Whether this document came from a replica server
	IsReplica bool
	// CAS revision of the document
	Cas uint64
	// Document that was retrieved
	Document *wasmcloud__couchbase__types.Document
	// When the document should expire (nanoseconds)
	//
	// Deprecated: use expires-at instead
	ExpiresInNs *uint64
	// Time when the document expires
	//
	// This field may not be present if `document-get-options.with-expiry` is not set
	ExpiresAt *Time
}

func (v *DocumentGetReplicaResult) String() string { return "DocumentGetReplicaResult" }

func (v *DocumentGetReplicaResult) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 5)
	slog.Debug("writing field", "name", "is-replica")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v bool, w io.ByteWriter) error {
		if !v {
			slog.Debug("writing `false` byte")
			return w.WriteByte(0)
		}
		slog.Debug("writing `true` byte")
		return w.WriteByte(1)
	}(v.IsReplica, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `is-replica` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "cas")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.Cas, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `cas` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "document")
	write2, err := (v.Document).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `document` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "expires-in-ns")
	write3, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ExpiresInNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-in-ns` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "expires-at")
	write4, err := func(v *Time, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ExpiresAt, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-at` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Document - Remove ///
//
// Options for performing a document remove
type DocumentRemoveOptions struct {
	// CAS revision of the document
	Cas uint64
	// (Deprecated)
	// Traditional durability settings for persistence, only usable from Couchbase versions earlier than 6.0
	//
	// See: https://docs.couchbase.com/go-sdk/current/howtos/subdocument-operations.html#1.6@go-sdk::durability.adoc
	PersistTo uint64
	// (Deprecated)
	// Traditional durability settings for replication, only usable from Couchbase versions earlier than 6.0
	//
	// See: https://docs.couchbase.com/go-sdk/current/howtos/subdocument-operations.html#1.6@go-sdk::durability.adoc
	ReplicateTo uint64
	// Durability level for the mutation
	//
	// (this should be used instead of persist-to/replicate-to)
	DurabilityLevel wasmcloud__couchbase__types.DurabilityLevel
	// Timeout that should be used, in nanoseconds
	// Even if a timeout is not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentRemoveOptions) String() string { return "DocumentRemoveOptions" }

func (v *DocumentRemoveOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 7)
	slog.Debug("writing field", "name", "cas")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.Cas, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `cas` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "persist-to")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.PersistTo, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `persist-to` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "replicate-to")
	write2, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ReplicateTo, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `replicate-to` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "durability-level")
	write3, err := (v.DurabilityLevel).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `durability-level` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write4, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write5, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write5 != nil {
		writes[5] = write5
	}
	slog.Debug("writing field", "name", "parent-span")
	write6, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write6 != nil {
		writes[6] = write6
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Document - Get and Lock ///
//
// Options for performing a document lock
type DocumentGetAndLockOptions struct {
	// Amount of time to lock the document (nanoseconds)
	LockTime uint64
	// Timeout that should be used, in nanoseconds
	// Even if a timeout is not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentGetAndLockOptions) String() string { return "DocumentGetAndLockOptions" }

func (v *DocumentGetAndLockOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "lock-time")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.LockTime, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `lock-time` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write1, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write2, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "parent-span")
	write3, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Document - Unlock ///
//
// Options for performing a document lock
type DocumentUnlockOptions struct {
	// CAS revision of the document
	Cas uint64
	// Timeout that should be used, in nanoseconds
	// Even if a timeout is not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentUnlockOptions) String() string { return "DocumentUnlockOptions" }

func (v *DocumentUnlockOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "cas")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.Cas, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `cas` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write1, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write2, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "parent-span")
	write3, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Document - Touch ///
//
// Options for performing a document lock
type DocumentTouchOptions struct {
	// Time until the document expires (nanoseconds)
	ExpiresIn uint64
	// Timeout that should be used, in nanoseconds
	// Even if a timeout is not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentTouchOptions) String() string { return "DocumentTouchOptions" }

func (v *DocumentTouchOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "expires-in")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ExpiresIn, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-in` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write1, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write2, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "parent-span")
	write3, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Document - Get and Touch ///
//
// Options for performing a document touch
type DocumentGetAndTouchOptions struct {
	// Time until the document expires (nanoseconds)
	ExpiresIn uint64
	// Timeout that should be used, in nanoseconds
	// Even if a timeout is not specified, the implementer *may* provide a default timeout.
	TimeoutNs *uint64
	// How and whether to retry the operation
	RetryStrategy *RetryStrategy
	// A known span to associate this lookup with
	ParentSpan *RequestSpan
}

func (v *DocumentGetAndTouchOptions) String() string { return "DocumentGetAndTouchOptions" }

func (v *DocumentGetAndTouchOptions) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "expires-in")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.ExpiresIn, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `expires-in` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "timeout-ns")
	write1, err := func(v *uint64, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.TimeoutNs, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `timeout-ns` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "retry-strategy")
	write2, err := func(v *RetryStrategy, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (v).WriteToIndex(w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.RetryStrategy, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `retry-strategy` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "parent-span")
	write3, err := func(v *RequestSpan, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(v.ParentSpan, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `parent-span` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

type Handler interface {
	// Insert a document with a new ID
	Insert(ctx__ context.Context, id string, doc *wasmcloud__couchbase__types.Document, options *DocumentInsertOptions) (*wrpc.Result[MutationMetadata, DocumentError], error)
	// Replace a document with the given ID with a new document
	Replace(ctx__ context.Context, id string, doc *wasmcloud__couchbase__types.Document, options *DocumentReplaceOptions) (*wrpc.Result[MutationMetadata, DocumentError], error)
	// Create or update (replace) an existing document with the given ID
	Upsert(ctx__ context.Context, id string, doc *wasmcloud__couchbase__types.Document, options *DocumentUpsertOptions) (*wrpc.Result[MutationMetadata, DocumentError], error)
	// Retrieve a document by ID
	Get(ctx__ context.Context, id string, options *DocumentGetOptions) (*wrpc.Result[DocumentGetResult, DocumentError], error)
	// Retrieve a document by ID from any replica
	GetAnyRepliacs(ctx__ context.Context, id string, options *DocumentGetAnyReplicaOptions) (*wrpc.Result[DocumentGetReplicaResult, DocumentError], error)
	// Retrieve a document by ID from all replicas
	GetAllReplicas(ctx__ context.Context, id string, options *DocumentGetAllReplicaOptions) (*wrpc.Result[[]*DocumentGetReplicaResult, DocumentError], error)
	// Remove a document by ID
	Remove(ctx__ context.Context, id string, options *DocumentRemoveOptions) (*wrpc.Result[MutationMetadata, DocumentError], error)
	// Retrieve and Lock a document by ID
	GetAndLock(ctx__ context.Context, id string, options *DocumentGetAndLockOptions) (*wrpc.Result[DocumentGetResult, DocumentError], error)
	// Retrieve and Lock a document by ID
	Unlock(ctx__ context.Context, id string, options *DocumentUnlockOptions) (*wrpc.Result[struct{}, DocumentError], error)
	// Retrieve and Lock a document by ID
	Touch(ctx__ context.Context, id string, options *DocumentTouchOptions) (*wrpc.Result[MutationMetadata, DocumentError], error)
	// Retrieve and Touch a document by ID
	GetAndTouch(ctx__ context.Context, id string, options *DocumentGetAndTouchOptions) (*wrpc.Result[DocumentGetResult, DocumentError], error)
}

func ServeInterface(s wrpc.Server, h Handler) (stop func() error, err error) {
	stops := make([]func() error, 0, 11)
	stop = func() error {
		for _, stop := range stops {
			if err := stop(); err != nil {
				return err
			}
		}
		return nil
	}

	stop0, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "insert", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func() (*Document, error) {
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.Document, error) {
				v := &wasmcloud__couchbase__types.Document{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch wasmcloud__couchbase__types.DocumentDiscriminant(n) {
				case wasmcloud__couchbase__types.DocumentRaw:
					payload, err := func() (wasmcloud__couchbase__types.JsonString, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasmcloud__couchbase__types.JsonString)(v), err
					}()

					if err != nil {
						return nil, fmt.Errorf("failed to read `raw` payload: %w", err)
					}
					return v.SetRaw(payload), nil
				case wasmcloud__couchbase__types.DocumentResource:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (wrpc.Own[wasmcloud__couchbase__types.DocumentValue], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading owned resource handle length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read owned resource handle length byte: %w", err)
							}
							if b < 0x80 {
								if i == 4 && b > 1 {
									return nil, errors.New("owned resource handle length overflows a 32-bit integer")
								}
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading owned resource handle bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return nil, fmt.Errorf("failed to read owned resource handle bytes: %w", err)
								}
								return wrpc.Own[wasmcloud__couchbase__types.DocumentValue](buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("owned resource handle length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `resource` payload: %w", err)
					}
					return v.SetResource(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, []uint32{1}...)
			return (*Document)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 2)
		p2, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentInsertOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentInsertOptions, error) {
					v := &DocumentInsertOptions{}
					var err error
					slog.Debug("reading field", "name", "expires-in-ns")
					v.ExpiresInNs, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `expires-in-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "persist-to")
					v.PersistTo, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `persist-to` field: %w", err)
					}
					slog.Debug("reading field", "name", "replicate-to")
					v.ReplicateTo, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `replicate-to` field: %w", err)
					}
					slog.Debug("reading field", "name", "durability-level")
					v.DurabilityLevel, err = func() (DurabilityLevel, error) {
						v, err := func(r io.ByteReader) (v wasmcloud__couchbase__types.DurabilityLevel, err error) {
							n, err := func(r io.ByteReader) (uint8, error) {
								var x uint8
								var s uint
								for i := 0; i < 2; i++ {
									slog.Debug("reading u8 discriminant byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
									}
									if s == 7 && b > 0x01 {
										return x, errors.New("discriminant overflows an 8-bit integer")
									}
									if b < 0x80 {
										return x | uint8(b)<<s, nil
									}
									x |= uint8(b&0x7f) << s
									s += 7
								}
								return x, errors.New("discriminant overflows an 8-bit integer")
							}(r)
							if err != nil {
								return v, fmt.Errorf("failed to read discriminant: %w", err)
							}
							switch wasmcloud__couchbase__types.DurabilityLevel(n) {
							case wasmcloud__couchbase__types.DurabilityLevel_Unknown:
								return wasmcloud__couchbase__types.DurabilityLevel_Unknown, nil
							case wasmcloud__couchbase__types.DurabilityLevel_None:
								return wasmcloud__couchbase__types.DurabilityLevel_None, nil
							case wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajority:
								return wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajority, nil
							case wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajorityPersistMaster:
								return wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajorityPersistMaster, nil
							case wasmcloud__couchbase__types.DurabilityLevel_PersistMajority:
								return wasmcloud__couchbase__types.DurabilityLevel_PersistMajority, nil
							default:
								return v, fmt.Errorf("unknown discriminant value %d", n)
							}
						}(r)
						return (DurabilityLevel)(v), err
					}()

					if err != nil {
						return nil, fmt.Errorf("failed to read `durability-level` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 4)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 5)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 6)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{2}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 2, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.insert` handler")
		r0, err := h.Insert(ctx, p0, p1, p2)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[MutationMetadata, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.insert` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "insert", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.insert`: %w", err)
	}
	stops = append(stops, stop0)

	stop1, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "replace", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func() (*Document, error) {
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.Document, error) {
				v := &wasmcloud__couchbase__types.Document{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch wasmcloud__couchbase__types.DocumentDiscriminant(n) {
				case wasmcloud__couchbase__types.DocumentRaw:
					payload, err := func() (wasmcloud__couchbase__types.JsonString, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasmcloud__couchbase__types.JsonString)(v), err
					}()

					if err != nil {
						return nil, fmt.Errorf("failed to read `raw` payload: %w", err)
					}
					return v.SetRaw(payload), nil
				case wasmcloud__couchbase__types.DocumentResource:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (wrpc.Own[wasmcloud__couchbase__types.DocumentValue], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading owned resource handle length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read owned resource handle length byte: %w", err)
							}
							if b < 0x80 {
								if i == 4 && b > 1 {
									return nil, errors.New("owned resource handle length overflows a 32-bit integer")
								}
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading owned resource handle bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return nil, fmt.Errorf("failed to read owned resource handle bytes: %w", err)
								}
								return wrpc.Own[wasmcloud__couchbase__types.DocumentValue](buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("owned resource handle length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `resource` payload: %w", err)
					}
					return v.SetResource(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, []uint32{1}...)
			return (*Document)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 2)
		p2, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentReplaceOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentReplaceOptions, error) {
					v := &DocumentReplaceOptions{}
					var err error
					slog.Debug("reading field", "name", "cas")
					v.Cas, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `cas` field: %w", err)
					}
					slog.Debug("reading field", "name", "expires-in-ns")
					v.ExpiresInNs, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `expires-in-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "preserve-expiry")
					v.PreserveExpiry, err = func(r io.ByteReader) (bool, error) {
						slog.Debug("reading bool byte")
						v, err := r.ReadByte()
						if err != nil {
							slog.Debug("reading bool", "value", false)
							return false, fmt.Errorf("failed to read bool byte: %w", err)
						}
						switch v {
						case 0:
							return false, nil
						case 1:
							return true, nil
						default:
							return false, fmt.Errorf("invalid bool value %d", v)
						}
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `preserve-expiry` field: %w", err)
					}
					slog.Debug("reading field", "name", "persist-to")
					v.PersistTo, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `persist-to` field: %w", err)
					}
					slog.Debug("reading field", "name", "replicate-to")
					v.ReplicateTo, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `replicate-to` field: %w", err)
					}
					slog.Debug("reading field", "name", "durability-level")
					v.DurabilityLevel, err = func() (DurabilityLevel, error) {
						v, err := func(r io.ByteReader) (v wasmcloud__couchbase__types.DurabilityLevel, err error) {
							n, err := func(r io.ByteReader) (uint8, error) {
								var x uint8
								var s uint
								for i := 0; i < 2; i++ {
									slog.Debug("reading u8 discriminant byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
									}
									if s == 7 && b > 0x01 {
										return x, errors.New("discriminant overflows an 8-bit integer")
									}
									if b < 0x80 {
										return x | uint8(b)<<s, nil
									}
									x |= uint8(b&0x7f) << s
									s += 7
								}
								return x, errors.New("discriminant overflows an 8-bit integer")
							}(r)
							if err != nil {
								return v, fmt.Errorf("failed to read discriminant: %w", err)
							}
							switch wasmcloud__couchbase__types.DurabilityLevel(n) {
							case wasmcloud__couchbase__types.DurabilityLevel_Unknown:
								return wasmcloud__couchbase__types.DurabilityLevel_Unknown, nil
							case wasmcloud__couchbase__types.DurabilityLevel_None:
								return wasmcloud__couchbase__types.DurabilityLevel_None, nil
							case wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajority:
								return wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajority, nil
							case wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajorityPersistMaster:
								return wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajorityPersistMaster, nil
							case wasmcloud__couchbase__types.DurabilityLevel_PersistMajority:
								return wasmcloud__couchbase__types.DurabilityLevel_PersistMajority, nil
							default:
								return v, fmt.Errorf("unknown discriminant value %d", n)
							}
						}(r)
						return (DurabilityLevel)(v), err
					}()

					if err != nil {
						return nil, fmt.Errorf("failed to read `durability-level` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 6)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 7)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 8)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{2}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 2, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.replace` handler")
		r0, err := h.Replace(ctx, p0, p1, p2)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[MutationMetadata, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.replace` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "replace", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.replace`: %w", err)
	}
	stops = append(stops, stop1)

	stop2, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "upsert", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func() (*Document, error) {
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.Document, error) {
				v := &wasmcloud__couchbase__types.Document{}
				n, err := func(r io.ByteReader) (uint8, error) {
					var x uint8
					var s uint
					for i := 0; i < 2; i++ {
						slog.Debug("reading u8 discriminant byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
						}
						if s == 7 && b > 0x01 {
							return x, errors.New("discriminant overflows an 8-bit integer")
						}
						if b < 0x80 {
							return x | uint8(b)<<s, nil
						}
						x |= uint8(b&0x7f) << s
						s += 7
					}
					return x, errors.New("discriminant overflows an 8-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read discriminant: %w", err)
				}
				switch wasmcloud__couchbase__types.DocumentDiscriminant(n) {
				case wasmcloud__couchbase__types.DocumentRaw:
					payload, err := func() (wasmcloud__couchbase__types.JsonString, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasmcloud__couchbase__types.JsonString)(v), err
					}()

					if err != nil {
						return nil, fmt.Errorf("failed to read `raw` payload: %w", err)
					}
					return v.SetRaw(payload), nil
				case wasmcloud__couchbase__types.DocumentResource:
					payload, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (wrpc.Own[wasmcloud__couchbase__types.DocumentValue], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading owned resource handle length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read owned resource handle length byte: %w", err)
							}
							if b < 0x80 {
								if i == 4 && b > 1 {
									return nil, errors.New("owned resource handle length overflows a 32-bit integer")
								}
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading owned resource handle bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return nil, fmt.Errorf("failed to read owned resource handle bytes: %w", err)
								}
								return wrpc.Own[wasmcloud__couchbase__types.DocumentValue](buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("owned resource handle length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `resource` payload: %w", err)
					}
					return v.SetResource(payload), nil
				default:
					return nil, fmt.Errorf("unknown discriminant value %d", n)
				}
			}(r, []uint32{1}...)
			return (*Document)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 2)
		p2, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentUpsertOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentUpsertOptions, error) {
					v := &DocumentUpsertOptions{}
					var err error
					slog.Debug("reading field", "name", "expires-in-ns")
					v.ExpiresInNs, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `expires-in-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "preserve-expiry")
					v.PreserveExpiry, err = func(r io.ByteReader) (bool, error) {
						slog.Debug("reading bool byte")
						v, err := r.ReadByte()
						if err != nil {
							slog.Debug("reading bool", "value", false)
							return false, fmt.Errorf("failed to read bool byte: %w", err)
						}
						switch v {
						case 0:
							return false, nil
						case 1:
							return true, nil
						default:
							return false, fmt.Errorf("invalid bool value %d", v)
						}
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `preserve-expiry` field: %w", err)
					}
					slog.Debug("reading field", "name", "persist-to")
					v.PersistTo, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `persist-to` field: %w", err)
					}
					slog.Debug("reading field", "name", "replicate-to")
					v.ReplicateTo, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `replicate-to` field: %w", err)
					}
					slog.Debug("reading field", "name", "durability-level")
					v.DurabilityLevel, err = func() (DurabilityLevel, error) {
						v, err := func(r io.ByteReader) (v wasmcloud__couchbase__types.DurabilityLevel, err error) {
							n, err := func(r io.ByteReader) (uint8, error) {
								var x uint8
								var s uint
								for i := 0; i < 2; i++ {
									slog.Debug("reading u8 discriminant byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
									}
									if s == 7 && b > 0x01 {
										return x, errors.New("discriminant overflows an 8-bit integer")
									}
									if b < 0x80 {
										return x | uint8(b)<<s, nil
									}
									x |= uint8(b&0x7f) << s
									s += 7
								}
								return x, errors.New("discriminant overflows an 8-bit integer")
							}(r)
							if err != nil {
								return v, fmt.Errorf("failed to read discriminant: %w", err)
							}
							switch wasmcloud__couchbase__types.DurabilityLevel(n) {
							case wasmcloud__couchbase__types.DurabilityLevel_Unknown:
								return wasmcloud__couchbase__types.DurabilityLevel_Unknown, nil
							case wasmcloud__couchbase__types.DurabilityLevel_None:
								return wasmcloud__couchbase__types.DurabilityLevel_None, nil
							case wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajority:
								return wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajority, nil
							case wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajorityPersistMaster:
								return wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajorityPersistMaster, nil
							case wasmcloud__couchbase__types.DurabilityLevel_PersistMajority:
								return wasmcloud__couchbase__types.DurabilityLevel_PersistMajority, nil
							default:
								return v, fmt.Errorf("unknown discriminant value %d", n)
							}
						}(r)
						return (DurabilityLevel)(v), err
					}()

					if err != nil {
						return nil, fmt.Errorf("failed to read `durability-level` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 5)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 6)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 7)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{2}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 2, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.upsert` handler")
		r0, err := h.Upsert(ctx, p0, p1, p2)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[MutationMetadata, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.upsert` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "upsert", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.upsert`: %w", err)
	}
	stops = append(stops, stop2)

	stop3, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "get", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetOptions, error) {
					v := &DocumentGetOptions{}
					var err error
					slog.Debug("reading field", "name", "with-expiry")
					v.WithExpiry, err = func(r io.ByteReader) (bool, error) {
						slog.Debug("reading bool byte")
						v, err := r.ReadByte()
						if err != nil {
							slog.Debug("reading bool", "value", false)
							return false, fmt.Errorf("failed to read bool byte: %w", err)
						}
						switch v {
						case 0:
							return false, nil
						case 1:
							return true, nil
						default:
							return false, fmt.Errorf("invalid bool value %d", v)
						}
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `with-expiry` field: %w", err)
					}
					slog.Debug("reading field", "name", "project")
					v.Project, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]string, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r wrpc.IndexReadCloser, path ...uint32) ([]string, error) {
								var x uint32
								var s uint
								for i := 0; i < 5; i++ {
									slog.Debug("reading list length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return nil, fmt.Errorf("failed to read list length byte: %w", err)
									}
									if b < 0x80 {
										if i == 4 && b > 1 {
											return nil, errors.New("list length overflows a 32-bit integer")
										}
										x = x | uint32(b)<<s
										vs := make([]string, x)
										for i := range vs {
											slog.Debug("reading list element", "i", i)
											vs[i], err = func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
											}
										}
										return vs, nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return nil, errors.New("list length overflows a 32-bit integer")
							}(r, path...)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 1)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `project` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "use-replica")
					v.UseReplica, err = func(r wrpc.IndexReadCloser, path ...uint32) (*ReplicaReadLevel, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (ReplicaReadLevel, error) {
								v, err := func(r io.ByteReader) (v wasmcloud__couchbase__types.ReplicaReadLevel, err error) {
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return v, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.ReplicaReadLevel(n) {
									case wasmcloud__couchbase__types.ReplicaReadLevel_Off:
										return wasmcloud__couchbase__types.ReplicaReadLevel_Off, nil
									case wasmcloud__couchbase__types.ReplicaReadLevel_On:
										return wasmcloud__couchbase__types.ReplicaReadLevel_On, nil
									default:
										return v, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r)
								return (ReplicaReadLevel)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 4)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `use-replica` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 5)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.get` handler")
		r0, err := h.Get(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[DocumentGetResult, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.get` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.get`: %w", err)
	}
	stops = append(stops, stop3)

	stop4, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "get-any-repliacs", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetAnyReplicaOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetAnyReplicaOptions, error) {
					v := &DocumentGetAnyReplicaOptions{}
					var err error
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 0)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 1)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.get-any-repliacs` handler")
		r0, err := h.GetAnyRepliacs(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[DocumentGetReplicaResult, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.get-any-repliacs` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-any-repliacs", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.get-any-repliacs`: %w", err)
	}
	stops = append(stops, stop4)

	stop5, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "get-all-replicas", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetAllReplicaOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetAllReplicaOptions, error) {
					v := &DocumentGetAllReplicaOptions{}
					var err error
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 0)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 1)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.get-all-replicas` handler")
		r0, err := h.GetAllReplicas(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[[]*DocumentGetReplicaResult, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := func(v []*DocumentGetReplicaResult, w interface {
					io.ByteWriter
					io.Writer
				}) (write func(wrpc.IndexWriter) error, err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing list length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
					}
					slog.Debug("writing list elements")
					writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
					for i, e := range v {
						write, err := (e).WriteToIndex(w)
						if err != nil {
							return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
						}
						if write != nil {
							writes[uint32(i)] = write
						}
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg sync.WaitGroup
							var wgErr atomic.Value
							for index, write := range writes {
								wg.Add(1)
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index nested list writer: %w", err)
								}
								write := write
								go func() {
									defer wg.Done()
									if err := write(w); err != nil {
										wgErr.Store(err)
									}
								}()
							}
							wg.Wait()
							err := wgErr.Load()
							if err == nil {
								return nil
							}
							return err.(error)
						}, nil
					}
					return nil, nil
				}(*v.Ok, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.get-all-replicas` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-all-replicas", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.get-all-replicas`: %w", err)
	}
	stops = append(stops, stop5)

	stop6, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "remove", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentRemoveOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentRemoveOptions, error) {
					v := &DocumentRemoveOptions{}
					var err error
					slog.Debug("reading field", "name", "cas")
					v.Cas, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `cas` field: %w", err)
					}
					slog.Debug("reading field", "name", "persist-to")
					v.PersistTo, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `persist-to` field: %w", err)
					}
					slog.Debug("reading field", "name", "replicate-to")
					v.ReplicateTo, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `replicate-to` field: %w", err)
					}
					slog.Debug("reading field", "name", "durability-level")
					v.DurabilityLevel, err = func() (DurabilityLevel, error) {
						v, err := func(r io.ByteReader) (v wasmcloud__couchbase__types.DurabilityLevel, err error) {
							n, err := func(r io.ByteReader) (uint8, error) {
								var x uint8
								var s uint
								for i := 0; i < 2; i++ {
									slog.Debug("reading u8 discriminant byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
									}
									if s == 7 && b > 0x01 {
										return x, errors.New("discriminant overflows an 8-bit integer")
									}
									if b < 0x80 {
										return x | uint8(b)<<s, nil
									}
									x |= uint8(b&0x7f) << s
									s += 7
								}
								return x, errors.New("discriminant overflows an 8-bit integer")
							}(r)
							if err != nil {
								return v, fmt.Errorf("failed to read discriminant: %w", err)
							}
							switch wasmcloud__couchbase__types.DurabilityLevel(n) {
							case wasmcloud__couchbase__types.DurabilityLevel_Unknown:
								return wasmcloud__couchbase__types.DurabilityLevel_Unknown, nil
							case wasmcloud__couchbase__types.DurabilityLevel_None:
								return wasmcloud__couchbase__types.DurabilityLevel_None, nil
							case wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajority:
								return wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajority, nil
							case wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajorityPersistMaster:
								return wasmcloud__couchbase__types.DurabilityLevel_ReplicateMajorityPersistMaster, nil
							case wasmcloud__couchbase__types.DurabilityLevel_PersistMajority:
								return wasmcloud__couchbase__types.DurabilityLevel_PersistMajority, nil
							default:
								return v, fmt.Errorf("unknown discriminant value %d", n)
							}
						}(r)
						return (DurabilityLevel)(v), err
					}()

					if err != nil {
						return nil, fmt.Errorf("failed to read `durability-level` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 4)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 5)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 6)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.remove` handler")
		r0, err := h.Remove(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[MutationMetadata, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.remove` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "remove", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.remove`: %w", err)
	}
	stops = append(stops, stop6)

	stop7, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "get-and-lock", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetAndLockOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetAndLockOptions, error) {
					v := &DocumentGetAndLockOptions{}
					var err error
					slog.Debug("reading field", "name", "lock-time")
					v.LockTime, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `lock-time` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 1)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.get-and-lock` handler")
		r0, err := h.GetAndLock(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[DocumentGetResult, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.get-and-lock` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-lock", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.get-and-lock`: %w", err)
	}
	stops = append(stops, stop7)

	stop8, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "unlock", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentUnlockOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentUnlockOptions, error) {
					v := &DocumentUnlockOptions{}
					var err error
					slog.Debug("reading field", "name", "cas")
					v.Cas, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `cas` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 1)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.unlock` handler")
		r0, err := h.Unlock(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[struct{}, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.unlock` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "unlock", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.unlock`: %w", err)
	}
	stops = append(stops, stop8)

	stop9, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "touch", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentTouchOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentTouchOptions, error) {
					v := &DocumentTouchOptions{}
					var err error
					slog.Debug("reading field", "name", "expires-in")
					v.ExpiresIn, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `expires-in` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 1)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.touch` handler")
		r0, err := h.Touch(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[MutationMetadata, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.touch` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "touch", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.touch`: %w", err)
	}
	stops = append(stops, stop9)

	stop10, err := s.Serve("wasmcloud:couchbase/document@0.1.0-draft", "get-and-touch", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (DocumentId, error) {
			v, err := func() (wasmcloud__couchbase__types.DocumentId, error) {
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				return (wasmcloud__couchbase__types.DocumentId)(v), err
			}()

			return (DocumentId)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetAndTouchOptions, error) {
			slog.Debug("reading option status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read option status byte: %w", err)
			}
			switch status {
			case 0:
				return nil, nil
			case 1:
				slog.Debug("reading `option::some` payload")
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*DocumentGetAndTouchOptions, error) {
					v := &DocumentGetAndTouchOptions{}
					var err error
					slog.Debug("reading field", "name", "expires-in")
					v.ExpiresIn, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `expires-in` field: %w", err)
					}
					slog.Debug("reading field", "name", "timeout-ns")
					v.TimeoutNs, err = func(r wrpc.IndexReadCloser, path ...uint32) (*uint64, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 1)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `timeout-ns` field: %w", err)
					}
					slog.Debug("reading field", "name", "retry-strategy")
					v.RetryStrategy, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RetryStrategy, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (*RetryStrategy, error) {
								v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wasmcloud__couchbase__types.RetryStrategy, error) {
									v := &wasmcloud__couchbase__types.RetryStrategy{}
									n, err := func(r io.ByteReader) (uint8, error) {
										var x uint8
										var s uint
										for i := 0; i < 2; i++ {
											slog.Debug("reading u8 discriminant byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
											}
											if s == 7 && b > 0x01 {
												return x, errors.New("discriminant overflows an 8-bit integer")
											}
											if b < 0x80 {
												return x | uint8(b)<<s, nil
											}
											x |= uint8(b&0x7f) << s
											s += 7
										}
										return x, errors.New("discriminant overflows an 8-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read discriminant: %w", err)
									}
									switch wasmcloud__couchbase__types.RetryStrategyDiscriminant(n) {
									case wasmcloud__couchbase__types.RetryStrategyIntervalTimesMs:
										payload, err := func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[uint64, uint64], error) {
											v := &wrpc.Tuple2[uint64, uint64]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r io.ByteReader) (uint64, error) {
												var x uint64
												var s uint8
												for i := 0; i < 10; i++ {
													slog.Debug("reading u64 byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return x, fmt.Errorf("failed to read u64 byte: %w", err)
													}
													if s == 63 && b > 0x01 {
														return x, errors.New("varint overflows a 64-bit integer")
													}
													if b < 0x80 {
														return x | uint64(b)<<s, nil
													}
													x |= uint64(b&0x7f) << s
													s += 7
												}
												return x, errors.New("varint overflows a 64-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, path...)
										if err != nil {
											return nil, fmt.Errorf("failed to read `interval-times-ms` payload: %w", err)
										}
										return v.SetIntervalTimesMs(payload), nil
									default:
										return nil, fmt.Errorf("unknown discriminant value %d", n)
									}
								}(r, path...)
								return (*RetryStrategy)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `retry-strategy` field: %w", err)
					}
					slog.Debug("reading field", "name", "parent-span")
					v.ParentSpan, err = func(r wrpc.IndexReadCloser, path ...uint32) (*RequestSpan, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func() (RequestSpan, error) {
								v, err := func() (wasmcloud__couchbase__types.RequestSpan, error) {
									v, err := func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									return (wasmcloud__couchbase__types.RequestSpan)(v), err
								}()

								return (RequestSpan)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `parent-span` field: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
				}
				return v, nil
			default:
				return nil, fmt.Errorf("invalid option status byte %d", status)
			}
		}(r, []uint32{1}...)

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:couchbase/document@0.1.0-draft.get-and-touch` handler")
		r0, err := h.GetAndTouch(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[DocumentGetResult, DocumentError], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:couchbase/document@0.1.0-draft.get-and-touch` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "wasmcloud:couchbase/document@0.1.0-draft", "name", "get-and-touch", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:couchbase/document@0.1.0-draft.get-and-touch`: %w", err)
	}
	stops = append(stops, stop10)
	return stop, nil
}

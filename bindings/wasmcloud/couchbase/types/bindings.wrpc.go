// Generated by `wit-bindgen-wrpc-go` 0.1.1. DO NOT EDIT!
package types

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wrpc "github.com/wrpc/wrpc/go"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	utf8 "unicode/utf8"
)

// ID of a Document
//
// Note that Document IDs are expected to be:
// - Assigned at the application level
// - Be valid UTF-8 at the application level
// - Be no longer than 250 bytes (not characters)
type DocumentId = string

// The span of a request, normally used when performing/enabling tracing
type RequestSpan = string

// A string that is properly formatted JSON
type JsonString = string

// Whether to enable replica reads for the request
type ReplicaReadLevel uint8

const (
	ReplicaReadLevel_Off ReplicaReadLevel = 0
	ReplicaReadLevel_On  ReplicaReadLevel = 1
)

func (v ReplicaReadLevel) String() string {
	switch v {
	case ReplicaReadLevel_Off:
		return "off"
	case ReplicaReadLevel_On:
		return "on"
	default:
		panic("invalid enum")
	}
}
func (v ReplicaReadLevel) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	return nil, nil
}

// Port of https://pkg.go.dev/time#Time
type Time struct {
	// Offsets are assumed to be against the western hemisphere (GMT)
	// i.e. -14 -> 0 -> +14 UTC
	Offset int8
	Year   int32
	Month  uint8
	Day    uint8
	// 24hr time (i.e. 6PM is represented as `18`)
	Hour         uint8
	Minute       uint8
	Second       uint8
	Milliseconds uint32
	Nanoseconds  uint32
}

func (v *Time) String() string { return "Time" }

func (v *Time) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 9)
	slog.Debug("writing field", "name", "offset")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v int8, w io.ByteWriter) error {
		slog.Debug("writing s8 byte")
		return w.WriteByte(byte(v))
	}(v.Offset, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `offset` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "year")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v int32, w io.ByteWriter) (err error) {
		for {
			b := byte(v & 0x7f)
			v >>= 7

			signb := b & 0x40

			last := false
			if (v == 0 && signb == 0) || (v == -1 && signb != 0) {
				last = true
			} else {
				b = b | 0x80
			}
			slog.Debug("writing s32 byte")
			if err = w.WriteByte(b); err != nil {
				return fmt.Errorf("failed to write `s32` byte: %w", err)
			}
			if last {
				return nil
			}
		}
	}(v.Year, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `year` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "month")
	write2, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
		slog.Debug("writing u8 byte")
		return w.WriteByte(v)
	}(v.Month, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `month` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "day")
	write3, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
		slog.Debug("writing u8 byte")
		return w.WriteByte(v)
	}(v.Day, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `day` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "hour")
	write4, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
		slog.Debug("writing u8 byte")
		return w.WriteByte(v)
	}(v.Hour, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `hour` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}
	slog.Debug("writing field", "name", "minute")
	write5, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
		slog.Debug("writing u8 byte")
		return w.WriteByte(v)
	}(v.Minute, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `minute` field: %w", err)
	}
	if write5 != nil {
		writes[5] = write5
	}
	slog.Debug("writing field", "name", "second")
	write6, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
		slog.Debug("writing u8 byte")
		return w.WriteByte(v)
	}(v.Second, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `second` field: %w", err)
	}
	if write6 != nil {
		writes[6] = write6
	}
	slog.Debug("writing field", "name", "milliseconds")
	write7, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen32)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u32")
		_, err = w.Write(b[:i])
		return err
	}(v.Milliseconds, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `milliseconds` field: %w", err)
	}
	if write7 != nil {
		writes[7] = write7
	}
	slog.Debug("writing field", "name", "nanoseconds")
	write8, err := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen32)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u32")
		_, err = w.Write(b[:i])
		return err
	}(v.Nanoseconds, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `nanoseconds` field: %w", err)
	}
	if write8 != nil {
		writes[8] = write8
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Errors that can occur during operations on documents
type DocumentError struct {
	payload      any
	discriminant DocumentErrorDiscriminant
}

func (v *DocumentError) Discriminant() DocumentErrorDiscriminant { return v.discriminant }

type DocumentErrorDiscriminant uint8

const (
	// Document could not be found
	DocumentErrorNotFound DocumentErrorDiscriminant = 0
	// CAS revision submitted to operation does not match value on server
	DocumentErrorCasMismatch DocumentErrorDiscriminant = 1
	// Document is locked
	DocumentErrorLocked DocumentErrorDiscriminant = 2
	// Unlock con a document that is not locked
	DocumentErrorNotLocked DocumentErrorDiscriminant = 3
	// Document cannot be retrieved (from any replica)
	DocumentErrorUnretrievable DocumentErrorDiscriminant = 4
	// Document already exists (i.e. a duplicate)
	DocumentErrorAlreadyExists DocumentErrorDiscriminant = 5
	// Document is not JSON
	DocumentErrorNotJson DocumentErrorDiscriminant = 6
	// Document does not contain the specified sub-document path
	DocumentErrorPathNotFound DocumentErrorDiscriminant = 7
	// Sub-document path is invalid (could not be parsed)
	DocumentErrorPathInvalid DocumentErrorDiscriminant = 8
	// Sub-document path is too deeply nested
	DocumentErrorPathTooDeep DocumentErrorDiscriminant = 9
	// Sub-document operation could not insert
	DocumentErrorInvalidValue DocumentErrorDiscriminant = 10
	// An invalid delta is used when performing a sub-document operation
	DocumentErrorSubdocumentDeltaInvalid DocumentErrorDiscriminant = 11
)

func (v *DocumentError) String() string {
	switch v.discriminant {
	case DocumentErrorNotFound:
		return "not-found"
	case DocumentErrorCasMismatch:
		return "cas-mismatch"
	case DocumentErrorLocked:
		return "locked"
	case DocumentErrorNotLocked:
		return "not-locked"
	case DocumentErrorUnretrievable:
		return "unretrievable"
	case DocumentErrorAlreadyExists:
		return "already-exists"
	case DocumentErrorNotJson:
		return "not-json"
	case DocumentErrorPathNotFound:
		return "path-not-found"
	case DocumentErrorPathInvalid:
		return "path-invalid"
	case DocumentErrorPathTooDeep:
		return "path-too-deep"
	case DocumentErrorInvalidValue:
		return "invalid-value"
	case DocumentErrorSubdocumentDeltaInvalid:
		return "subdocument-delta-invalid"
	default:
		panic("invalid variant")
	}
}

// Document could not be found
func (v *DocumentError) GetNotFound() (ok bool) {
	if ok = (v.discriminant == DocumentErrorNotFound); !ok {
		return
	}
	return
}

// Document could not be found
func (v *DocumentError) SetNotFound() *DocumentError {
	v.discriminant = DocumentErrorNotFound
	v.payload = nil
	return v
}

// Document could not be found
func NewDocumentErrorNotFound() *DocumentError {
	return (&DocumentError{}).SetNotFound()
}

// CAS revision submitted to operation does not match value on server
func (v *DocumentError) GetCasMismatch() (ok bool) {
	if ok = (v.discriminant == DocumentErrorCasMismatch); !ok {
		return
	}
	return
}

// CAS revision submitted to operation does not match value on server
func (v *DocumentError) SetCasMismatch() *DocumentError {
	v.discriminant = DocumentErrorCasMismatch
	v.payload = nil
	return v
}

// CAS revision submitted to operation does not match value on server
func NewDocumentErrorCasMismatch() *DocumentError {
	return (&DocumentError{}).SetCasMismatch()
}

// Document is locked
func (v *DocumentError) GetLocked() (ok bool) {
	if ok = (v.discriminant == DocumentErrorLocked); !ok {
		return
	}
	return
}

// Document is locked
func (v *DocumentError) SetLocked() *DocumentError {
	v.discriminant = DocumentErrorLocked
	v.payload = nil
	return v
}

// Document is locked
func NewDocumentErrorLocked() *DocumentError {
	return (&DocumentError{}).SetLocked()
}

// Unlock con a document that is not locked
func (v *DocumentError) GetNotLocked() (ok bool) {
	if ok = (v.discriminant == DocumentErrorNotLocked); !ok {
		return
	}
	return
}

// Unlock con a document that is not locked
func (v *DocumentError) SetNotLocked() *DocumentError {
	v.discriminant = DocumentErrorNotLocked
	v.payload = nil
	return v
}

// Unlock con a document that is not locked
func NewDocumentErrorNotLocked() *DocumentError {
	return (&DocumentError{}).SetNotLocked()
}

// Document cannot be retrieved (from any replica)
func (v *DocumentError) GetUnretrievable() (ok bool) {
	if ok = (v.discriminant == DocumentErrorUnretrievable); !ok {
		return
	}
	return
}

// Document cannot be retrieved (from any replica)
func (v *DocumentError) SetUnretrievable() *DocumentError {
	v.discriminant = DocumentErrorUnretrievable
	v.payload = nil
	return v
}

// Document cannot be retrieved (from any replica)
func NewDocumentErrorUnretrievable() *DocumentError {
	return (&DocumentError{}).SetUnretrievable()
}

// Document already exists (i.e. a duplicate)
func (v *DocumentError) GetAlreadyExists() (ok bool) {
	if ok = (v.discriminant == DocumentErrorAlreadyExists); !ok {
		return
	}
	return
}

// Document already exists (i.e. a duplicate)
func (v *DocumentError) SetAlreadyExists() *DocumentError {
	v.discriminant = DocumentErrorAlreadyExists
	v.payload = nil
	return v
}

// Document already exists (i.e. a duplicate)
func NewDocumentErrorAlreadyExists() *DocumentError {
	return (&DocumentError{}).SetAlreadyExists()
}

// Document is not JSON
func (v *DocumentError) GetNotJson() (ok bool) {
	if ok = (v.discriminant == DocumentErrorNotJson); !ok {
		return
	}
	return
}

// Document is not JSON
func (v *DocumentError) SetNotJson() *DocumentError {
	v.discriminant = DocumentErrorNotJson
	v.payload = nil
	return v
}

// Document is not JSON
func NewDocumentErrorNotJson() *DocumentError {
	return (&DocumentError{}).SetNotJson()
}

// Document does not contain the specified sub-document path
func (v *DocumentError) GetPathNotFound() (ok bool) {
	if ok = (v.discriminant == DocumentErrorPathNotFound); !ok {
		return
	}
	return
}

// Document does not contain the specified sub-document path
func (v *DocumentError) SetPathNotFound() *DocumentError {
	v.discriminant = DocumentErrorPathNotFound
	v.payload = nil
	return v
}

// Document does not contain the specified sub-document path
func NewDocumentErrorPathNotFound() *DocumentError {
	return (&DocumentError{}).SetPathNotFound()
}

// Sub-document path is invalid (could not be parsed)
func (v *DocumentError) GetPathInvalid() (ok bool) {
	if ok = (v.discriminant == DocumentErrorPathInvalid); !ok {
		return
	}
	return
}

// Sub-document path is invalid (could not be parsed)
func (v *DocumentError) SetPathInvalid() *DocumentError {
	v.discriminant = DocumentErrorPathInvalid
	v.payload = nil
	return v
}

// Sub-document path is invalid (could not be parsed)
func NewDocumentErrorPathInvalid() *DocumentError {
	return (&DocumentError{}).SetPathInvalid()
}

// Sub-document path is too deeply nested
func (v *DocumentError) GetPathTooDeep() (ok bool) {
	if ok = (v.discriminant == DocumentErrorPathTooDeep); !ok {
		return
	}
	return
}

// Sub-document path is too deeply nested
func (v *DocumentError) SetPathTooDeep() *DocumentError {
	v.discriminant = DocumentErrorPathTooDeep
	v.payload = nil
	return v
}

// Sub-document path is too deeply nested
func NewDocumentErrorPathTooDeep() *DocumentError {
	return (&DocumentError{}).SetPathTooDeep()
}

// Sub-document operation could not insert
func (v *DocumentError) GetInvalidValue() (ok bool) {
	if ok = (v.discriminant == DocumentErrorInvalidValue); !ok {
		return
	}
	return
}

// Sub-document operation could not insert
func (v *DocumentError) SetInvalidValue() *DocumentError {
	v.discriminant = DocumentErrorInvalidValue
	v.payload = nil
	return v
}

// Sub-document operation could not insert
func NewDocumentErrorInvalidValue() *DocumentError {
	return (&DocumentError{}).SetInvalidValue()
}

// An invalid delta is used when performing a sub-document operation
func (v *DocumentError) GetSubdocumentDeltaInvalid() (ok bool) {
	if ok = (v.discriminant == DocumentErrorSubdocumentDeltaInvalid); !ok {
		return
	}
	return
}

// An invalid delta is used when performing a sub-document operation
func (v *DocumentError) SetSubdocumentDeltaInvalid() *DocumentError {
	v.discriminant = DocumentErrorSubdocumentDeltaInvalid
	v.payload = nil
	return v
}

// An invalid delta is used when performing a sub-document operation
func NewDocumentErrorSubdocumentDeltaInvalid() *DocumentError {
	return (&DocumentError{}).SetSubdocumentDeltaInvalid()
}
func (v *DocumentError) Error() string { return v.String() }
func (v *DocumentError) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case DocumentErrorNotFound:
	case DocumentErrorCasMismatch:
	case DocumentErrorLocked:
	case DocumentErrorNotLocked:
	case DocumentErrorUnretrievable:
	case DocumentErrorAlreadyExists:
	case DocumentErrorNotJson:
	case DocumentErrorPathNotFound:
	case DocumentErrorPathInvalid:
	case DocumentErrorPathTooDeep:
	case DocumentErrorInvalidValue:
	case DocumentErrorSubdocumentDeltaInvalid:
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Errors that occur when building/using document values
type DocumentValueCreateError struct {
	payload      any
	discriminant DocumentValueCreateErrorDiscriminant
}

func (v *DocumentValueCreateError) Discriminant() DocumentValueCreateErrorDiscriminant {
	return v.discriminant
}

type DocumentValueCreateErrorDiscriminant uint8

const (
	// JSON used to create the document value was invalid
	DocumentValueCreateErrorInvalidJson DocumentValueCreateErrorDiscriminant = 0
)

func (v *DocumentValueCreateError) String() string {
	switch v.discriminant {
	case DocumentValueCreateErrorInvalidJson:
		return "invalid-json"
	default:
		panic("invalid variant")
	}
}

// JSON used to create the document value was invalid
func (v *DocumentValueCreateError) GetInvalidJson() (payload string, ok bool) {
	if ok = (v.discriminant == DocumentValueCreateErrorInvalidJson); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}

// JSON used to create the document value was invalid
func (v *DocumentValueCreateError) SetInvalidJson(payload string) *DocumentValueCreateError {
	v.discriminant = DocumentValueCreateErrorInvalidJson
	v.payload = payload
	return v
}

// JSON used to create the document value was invalid
func NewDocumentValueCreateErrorInvalidJson(payload string) *DocumentValueCreateError {
	return (&DocumentValueCreateError{}).SetInvalidJson(
		payload)
}
func (v *DocumentValueCreateError) Error() string { return v.String() }
func (v *DocumentValueCreateError) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case DocumentValueCreateErrorInvalidJson:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(0)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// WIT cannot currently support passing recursive value types, which means JSON cannot be properly
// represetned as a WIT level type.
//
// What we use instead is a variant with two types:
// - a valid JSON string (which may or may not be an object)
// - an implementer-controlled value which is a valid JSON object (as defined by the implementer)
//
// The implementer-controlled value can be any implementation (usually a more efficient one)
// that can be understood by the implementer. One requirement on this value is that it must be
// possible to convert it to/from a raw JSON string at any time.
//
// An opaque resource that represents a JSON value, and can be efficiently
// manipulated by implementers.
type Document struct {
	payload      any
	discriminant DocumentDiscriminant
}

func (v *Document) Discriminant() DocumentDiscriminant { return v.discriminant }

type DocumentDiscriminant uint8

const (
	// A stringified JSON value represented by a resource, often used by callers
	// that cannot or do not want to construct an efficient implementer specific JSON value
	DocumentRaw DocumentDiscriminant = 0
	// A JSON value represented by a more efficient but opaque implementer-specific representation
	DocumentResource DocumentDiscriminant = 1
)

func (v *Document) String() string {
	switch v.discriminant {
	case DocumentRaw:
		return "raw"
	case DocumentResource:
		return "resource"
	default:
		panic("invalid variant")
	}
}

// A stringified JSON value represented by a resource, often used by callers
// that cannot or do not want to construct an efficient implementer specific JSON value
func (v *Document) GetRaw() (payload JsonString, ok bool) {
	if ok = (v.discriminant == DocumentRaw); !ok {
		return
	}
	payload, ok = v.payload.(JsonString)
	return
}

// A stringified JSON value represented by a resource, often used by callers
// that cannot or do not want to construct an efficient implementer specific JSON value
func (v *Document) SetRaw(payload string) *Document {
	v.discriminant = DocumentRaw
	v.payload = payload
	return v
}

// A stringified JSON value represented by a resource, often used by callers
// that cannot or do not want to construct an efficient implementer specific JSON value
func NewDocumentRaw(payload string) *Document {
	return (&Document{}).SetRaw(
		payload)
}

// A JSON value represented by a more efficient but opaque implementer-specific representation
func (v *Document) GetResource() (payload wrpc.Own[DocumentValue], ok bool) {
	if ok = (v.discriminant == DocumentResource); !ok {
		return
	}
	payload, ok = v.payload.(wrpc.Own[DocumentValue])
	return
}

// A JSON value represented by a more efficient but opaque implementer-specific representation
func (v *Document) SetResource(payload wrpc.Own[DocumentValue]) *Document {
	v.discriminant = DocumentResource
	v.payload = payload
	return v
}

// A JSON value represented by a more efficient but opaque implementer-specific representation
func NewDocumentResource(payload wrpc.Own[DocumentValue]) *Document {
	return (&Document{}).SetResource(
		payload)
}
func (v *Document) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case DocumentRaw:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(0)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case DocumentResource:
		payload, ok := v.payload.(wrpc.Own[DocumentValue])
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(payload), w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(1)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Metadata related to any mutation on a Couchbase collection (ex. CRUD operations)
type MutationMetadata struct {
	// CAS revision of the document
	Cas uint64
	// The bucket on which the mutation was performed
	Bucket string
	// The ID of the vbucket (partition) that the operation was performed on
	PartitionId uint64
	// The UUID of the vbucket (partition) that the operation was performed on
	PartitionUuid uint64
	// The sequence number of the operation performed on the vbucket (partition)
	Seq uint64
}

func (v *MutationMetadata) String() string { return "MutationMetadata" }

func (v *MutationMetadata) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 5)
	slog.Debug("writing field", "name", "cas")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.Cas, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `cas` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "bucket")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Bucket, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `bucket` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "partition-id")
	write2, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.PartitionId, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `partition-id` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "partition-uuid")
	write3, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.PartitionUuid, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `partition-uuid` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}
	slog.Debug("writing field", "name", "seq")
	write4, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.Seq, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `seq` field: %w", err)
	}
	if write4 != nil {
		writes[4] = write4
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Durability level that should be used for operations
type DurabilityLevel uint8

const (
	DurabilityLevel_Unknown DurabilityLevel = 0
	DurabilityLevel_None    DurabilityLevel = 1
	// Replicate (hold in memory) to a majority of nodes
	DurabilityLevel_ReplicateMajority DurabilityLevel = 2
	// Replicate (hold in memory) to a majority of nodes, persist (write to disk) to master
	DurabilityLevel_ReplicateMajorityPersistMaster DurabilityLevel = 3
	// Persist to a majority of nodes
	DurabilityLevel_PersistMajority DurabilityLevel = 4
)

func (v DurabilityLevel) String() string {
	switch v {
	case DurabilityLevel_Unknown:
		return "unknown"
	case DurabilityLevel_None:
		return "none"
	case DurabilityLevel_ReplicateMajority:
		return "replicate-majority"
	case DurabilityLevel_ReplicateMajorityPersistMaster:
		return "replicate-majority-persist-master"
	case DurabilityLevel_PersistMajority:
		return "persist-majority"
	default:
		panic("invalid enum")
	}
}
func (v DurabilityLevel) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	return nil, nil
}

// As functions cannot be represented as part of types in WIT,
// we represent static retry strategies
type RetryStrategy struct {
	payload      any
	discriminant RetryStrategyDiscriminant
}

func (v *RetryStrategy) Discriminant() RetryStrategyDiscriminant { return v.discriminant }

type RetryStrategyDiscriminant uint8

const (
	// Retry a certain number of times with a given interval between each retry)
	RetryStrategyIntervalTimesMs RetryStrategyDiscriminant = 0
)

func (v *RetryStrategy) String() string {
	switch v.discriminant {
	case RetryStrategyIntervalTimesMs:
		return "interval-times-ms"
	default:
		panic("invalid variant")
	}
}

// Retry a certain number of times with a given interval between each retry)
func (v *RetryStrategy) GetIntervalTimesMs() (payload wrpc.Tuple2[uint64, uint64], ok bool) {
	if ok = (v.discriminant == RetryStrategyIntervalTimesMs); !ok {
		return
	}
	payload, ok = v.payload.(wrpc.Tuple2[uint64, uint64])
	return
}

// Retry a certain number of times with a given interval between each retry)
func (v *RetryStrategy) SetIntervalTimesMs(payload *wrpc.Tuple2[uint64, uint64]) *RetryStrategy {
	v.discriminant = RetryStrategyIntervalTimesMs
	v.payload = payload
	return v
}

// Retry a certain number of times with a given interval between each retry)
func NewRetryStrategyIntervalTimesMs(payload *wrpc.Tuple2[uint64, uint64]) *RetryStrategy {
	return (&RetryStrategy{}).SetIntervalTimesMs(
		payload)
}
func (v *RetryStrategy) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case RetryStrategyIntervalTimesMs:
		payload, ok := v.payload.(*wrpc.Tuple2[uint64, uint64])
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := func(v *wrpc.Tuple2[uint64, uint64], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
			slog.Debug("writing tuple element 0")
			write0, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen64)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u64")
				_, err = w.Write(b[:i])
				return err
			}(v.V0, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
			}
			if write0 != nil {
				writes[0] = write0
			}
			slog.Debug("writing tuple element 1")
			write1, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
				b := make([]byte, binary.MaxVarintLen64)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing u64")
				_, err = w.Write(b[:i])
				return err
			}(v.V1, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
			}
			if write1 != nil {
				writes[1] = write1
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg sync.WaitGroup
					var wgErr atomic.Value
					for index, write := range writes {
						wg.Add(1)
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						go func() {
							defer wg.Done()
							if err := write(w); err != nil {
								wgErr.Store(err)
							}
						}()
					}
					wg.Wait()
					err := wgErr.Load()
					if err == nil {
						return nil
					}
					return err.(error)
				}, nil
			}
			return nil, nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(0)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Construct an empty document value (a dictionary, by default)
func NewDocumentValue(ctx__ context.Context, wrpc__ wrpc.Invoker) (r0__ wrpc.Own[DocumentValue], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasmcloud:couchbase/types@0.1.0-draft", "document-value", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		_, err__ = w__.Write(nil)
		if err__ != nil {
			return fmt.Errorf("failed to write empty parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[DocumentValue], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[DocumentValue](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[constructor]document-value`: %w", err__)
		return
	}
	return
}

// Convert this JSON value into a string
func DocumentValue_ToString(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[DocumentValue]) (r0__ string, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "to-string", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (string, error) {
			var x uint32
			var s uint8
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if s == 28 && b > 0x0f {
					return "", errors.New("string length overflows a 32-bit integer")
				}
				if b < 0x80 {
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]document-value.to-string`: %w", err__)
		return
	}
	return
}

// Build a document-value from a stringified JSON value
func DocumentValue_FromJson(ctx__ context.Context, wrpc__ wrpc.Invoker, json string) (r0__ *wrpc.Result[wrpc.Own[DocumentValue], DocumentValueCreateError], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasmcloud:couchbase/types@0.1.0-draft", "document-value.from-json", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(json, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `json` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[DocumentValue], DocumentValueCreateError], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[DocumentValue], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[DocumentValue](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[DocumentValue], DocumentValueCreateError]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*DocumentValueCreateError, error) {
					v := &DocumentValueCreateError{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if s == 7 && b > 0x01 {
								return x, errors.New("discriminant overflows an 8-bit integer")
							}
							if b < 0x80 {
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch DocumentValueCreateErrorDiscriminant(n) {
					case DocumentValueCreateErrorInvalidJson:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `invalid-json` payload: %w", err)
						}
						return v.SetInvalidJson(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[DocumentValue], DocumentValueCreateError]{Err: v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]document-value.from-json`: %w", err__)
		return
	}
	return
}

type DocumentValue interface {
	// Convert this JSON value into a string
	ToString(ctx__ context.Context, wrpc__ wrpc.Invoker) (string, func() error, error)
}
